import logging
from types import GenericAlias
from typing import Any, Mapping, Optional, Sequence, get_args, get_origin, Type

from fastapi.datastructures import DefaultPlaceholder
from fastapi.responses import Response
from fastapi.routing import APIRoute, serialize_response
from fastapi.utils import is_body_allowed_for_status_code
from polyfactory import BaseFactory

logger = logging.getLogger(__name__)


class APINotImplementedError(NotImplementedError):
    def __init__(self, *, return_value: Any = None):
        """
        API NotImplementedError

        Exception class to be risen on unimplemented endpoints for mocking their
        response data by `MockAPIMiddleware`

        Args:
            return_value: Value to return as mock data. Optional, in most cases
                autogenerated data should be enough. Use when specific data
                is required or in complex cases where data mocking according to
                response model did not work as expected.
        """
        super().__init__()
        self.return_value = return_value


class MockAPIMiddleware:
    warning_msg = ('%s middleware is active. '
                   'Ensure that all APIs are implemented and middleware removed before deploying to production.')

    def __init__(
            self,
            app,
            not_implemented_error_class: Exception = APINotImplementedError,
            content_mocked_header_name: str = 'X-Content-Mocked'
    ):
        """
        Mock API middleware

        Mocks unimplemented endpoint responses with generated data according
        to their response models.

        Args:
            app: ASGI application
            not_implemented_error_class: Exception class on raising which
                middleware returns mocked response: Default:
                `APINotImplementedError`. It's not encouraged to use the
                built-in NotImplementedError not to confuse with the one
                intended for API mocking.
            content_mocked_header_name: response header name indicating that the
                response has been mocked. Default: `X-Content-Mocked`

        Usage example:
            ```python
            app = FastAPI()
            app.add_middleware(MockAPIMiddleware)
            ```

        Usage example with arguments:
            ```python
            app = FastAPI()
            app.add_middleware(MockAPIMiddleware,
                               not_implemented_error_class=APINotImplementedError,
                               content_mocked_header_name='X-Content-Mocked')
            ```
        """
        logger.warning(self.warning_msg % self.__class__.__name__)
        self.app = app
        self.not_implemented_error_class = not_implemented_error_class
        self.content_mocked_header_name = content_mocked_header_name

    async def __call__(self, scope, receive, send):
        try:
            await self.app(scope, receive, send)
        except self.not_implemented_error_class as not_implemented_error:
            try:
                if hasattr(not_implemented_error, 'return_value') and not_implemented_error.return_value:
                    content = not_implemented_error.return_value
                else:
                    content = await self.get_content(scope)
                response = await self.get_mock_response(scope, content)
                if not is_body_allowed_for_status_code(response.status_code):
                    response.body = b''
                await response(scope, receive, send)
                logger.warning(f'{scope["method"]} {scope["path"]} {response.status_code} mocked.')
            except Exception as mock_exc:
                # log mocking failure and return original endpoint exception
                logger.error(f'Failed to mock {scope["method"]} {scope["path"]}: {mock_exc}')
                raise not_implemented_error from None

    async def get_mock_response(self, scope, content: Any) -> Response:
        route: APIRoute = scope['route']
        response_class = (
            route.response_class.value
            if isinstance(route.response_class, DefaultPlaceholder)
            else route.response_class
        )
        response_args = {}
        if route.status_code:
            response_args['status_code'] = route.status_code
        return response_class(content, headers={self.content_mocked_header_name: '1'}, **response_args)

    def get_mock_factory_class(self, response_model: Any) -> Optional[Type[BaseFactory]]:
        for factory in BaseFactory.__subclasses__():
            if factory.is_supported_type(response_model):
                return factory

    async def get_content(self, scope) -> Optional[dict]:
        """Get generated content conforming to the route response model"""
        route: APIRoute = scope['route']
        if not route.response_model:
            return None
        if route.response_model is Any:
            return {}

        content = None
        factory_class = self.get_mock_factory_class(route.response_model)
        if factory_class:
            factory = factory_class.create_factory(model=route.response_model, __use_defaults__=True)
            content = factory.build()
        elif isinstance(route.response_model, GenericAlias) and issubclass(get_origin(route.response_model), Sequence):
            # e.g. list[Model]
            item_type = get_args(route.response_model)[0]
            factory_class = self.get_mock_factory_class(item_type)
            if factory_class:
                factory = factory_class.create_factory(model=item_type, __use_defaults__=True)
                content = [factory.build()]
            else:
                content = BaseFactory.__faker__.pylist(1, value_types=[item_type])
        elif isinstance(route.response_model, GenericAlias) and issubclass(get_origin(route.response_model), Mapping):
            # e.g. dict[str, Model]
            key_type, value_type = get_args(route.response_model)
            factory_class = self.get_mock_factory_class(value_type)
            if factory_class:
                factory = factory_class.create_factory(model=value_type, __use_defaults__=True)
                content = {
                    key_type(): factory.build()
                }
            else:
                content = BaseFactory.__faker__.pydict(1, value_types=[value_type])
        else:
            provider = BaseFactory.get_provider_map().get(route.response_model, None)
            if provider:
                content = provider()
            else:
                raise ValueError(f'Cannot mock {route.response_model.__name__}')

        content = await serialize_response(
            field=route.response_field,
            response_content=content,
            include=route.response_model_include,
            exclude=route.response_model_exclude,
            by_alias=route.response_model_by_alias,
            exclude_unset=route.response_model_exclude_unset,
            exclude_defaults=route.response_model_exclude_defaults,
            exclude_none=route.response_model_exclude_none,
        )
        return content
